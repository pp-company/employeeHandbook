##<center>测试篇</center>
预计学习测试篇4个小时
1. The Three Laws of TDD
By now everyone knows that TDD asks us to write unit tests first, before we write production code. But that rule is just the tip of the iceberg. Consider the following three laws:1
    1. First Law You may not write production code until you have written a failing unit test.
    2. Second Law You may not write more of a unit test than is sufficient to fail, and not compiling is failing.
    3. Third Law You may not write more production code than is sufficient to pass the currently failing test. 
2. 学会使用assert
[语法1](https://blog.csdn.net/qq_29699799/article/details/79947882)、
[语法2](https://blog.csdn.net/weixin_40912883/article/details/78643145)、
[语法3](https://www.cnblogs.com/hahaccy/p/8059585.html)
	1. assert.areequal（2,1+1）等于  注意:你希望得到的值在前面
	2. assert.notequal（3,1+1）不等于
	3. assert.greaterthan(4,3) 大于
	4. assert.lessthan(3,4)    小于
	5. .......

	assert不成立的时候会产生报错
3. 写测试的时候也要符合 [DEMETER准则](https://www.cnblogs.com/zh7791/p/7922960.html)，老板让你测试什么你就测试什么，不要测试多，也不要测试少。
例：测试一个机器人能不能说话，就不要测试机器人能不能走过来跟你说话
4. 要善用不等式去测试， 改变什么都用等号测试的习惯，不等式测试的时候又要善用不严格不等式去测试， 改变什么都用严格不等式去测试的
习惯。
	1. 能够用>=or<=去测试就不要用==去测试
    2. 能够用>=or<=去测试不要用>or<去测试
    3. 但是这不是告诉你什么都无脑的用不等式去测。
    例：1+1==2，就不要为了不等而不等，就不要用1+1>=2，该用 ==的时候就用 ==。
	4. 例子1：测试一个转账系统，假设有a、b两个账户，里面有x、y的钱，现在从a➡b有z金额的转移了，测试这个转移是否成功。
        ```
        assert.areequal(x-z,a.money)
        assert.areequal(y+z,b.money)
        ```
        但是，忽略了一个问题，老板没跟你说这个转账系统是免费的，你做了额外的假设
        ```
        assert.greaterthan(x-z,a.money)
        assert.greaterthan(y+z,b.money)
        ```
        如果这么测，又有问题了，老板没跟你说这个转账系统不是免费的，你又做了额外的假设
        ```
        assert.greaterEqual(x-z,a.money)
        assert.greaterEqual(y+z,b.money)
        ```
        总结：不要擅自做额外的假设，
        解释:
        1. 测试也有子类跟父类，之后可以写一个免费的测试类（子类）or不免费的测试类(子类)继承上面更一般性的测试，再去更具体的子测试里实现更具体的测试逻辑。
        2. 如果不这样，我们可以明显预见免费的测试和不免费的测试将涉及到重复的问题，大量的重复浪费时间。
        3. 总而言之，测试的继承关系应与被测试类的继承关系`大致`相同，即免费转账和收费转账继承转账，测试免费转账和测试收费转账继承测试转账。如果没有像这样提前规划好，一上来就直接假设没有手续费，当我们以后业务升级到可以收手续费的时候，那么之前写的测试就全部没用了。
        4. **总之，不要擅自做额外的假设**
    5. 例子2：有一个包子类，有一个人的类，人的类可以吃包子eat，也可以get它的饱和度fullness（假设一开始的饱和度为零）
        ```
        class 包{......}
        class People{
            void eat(包 b){......}
            double getFullness(){....}
            ......
        }
        ```
        为什么类里面都是省略......，因为公司使用测试驱动开发（TDD），先写测试，类里面什么都没有的时候，就要开始写测试
        测试代码:
        ```
        for(int i=1;i<=100;i++){
            人.eat(new 包)
            assert.areequal(i,人.getFullness())
        }
        ```
        问题1:人的类的胃写得好的话，是吃不下100个包子的，可能第10个之后就饱了，再吃就报错 或者不报错但是偷偷把包子扔垃圾桶了，总之饱和度不可能无限制往上涨
        问题2:给定的题目里面也从来没有告诉你吃了一个包子饱和度就+1，又做了一个额外的假设
        所以如果照以上这么写的话只能够测试那些写得很简单的人消化系统，如果是真的设计很精良的话这个测试完全是帮倒忙的，所以该怎么写呢？
        ```
        People people = new People();
        people.eat(new 包);
        double d=people.getFullness();
        people.eat(new 包);
        assert.LessEqual(d, people.getFullness());
        ......
        ```
        同理:可以检测更多包子的情况
	
    善用不等式可以使得测试的扩展性变得很强

5. 测试的时候注意要把误差考虑进去，比如我们要测试1/5=0.2
	没考虑误差:
    ```
    assert.areequal（0.2,1/5）
    ```
    编程语言的精确度问题需要考虑误差，第三个参数指：可以允许的误差范围
    ```
	assertEquals(0.2,1/5,0.0000001)   
    ```
    有时候测试出现无规律的失败，可能是你精度设置太高了。
6. 每个测试都要包含一个全空的测试，目的是为了确保其他环境配置没有出错，如果这个全空的测试都出现了问题，那么我们可以知道，不是测试出问题了是外在因素出问题了
7. 每个测试都要包含至少一个直接可以目测正确错误的测试（不能用第5条）
-例：
    ```
	class ExpFunction{
		void setX(double x){......};
		double getY(){.....};
	}
    ```
	测试代码例：
    ```
	ExpFunction exp = new ExpFunction();	
	exp.setX(0) 
	assertEquals(1,exp.getY(),0.0000001)
	exp.setX(一个负很大的数)
 	assertEquals(0,exp.getY(),0.0000001)
     ```
8. 当有大量结构相同的测试的时候，应该先抽取模板
	错误示范：
    ```
    ExpFunction exp = new ExpFunction();	
    exp.setX(1) 
    assertEquals(2.718,exp.getY(),0.001)
    exp.setX(2) 
    assertEquals(7.389,exp.getY(),0.001)
    exp.setX(3) 
    assertEquals(20.085,exp.getY(),0.001)
    exp.setX(4) 
    assertEquals(54.598,exp.getY(),0.001)
    exp.setX(5) 
    assertEquals(148.412,exp.getY(),0.001)
    ```
	正确示范:
    ```
    void calculationExp(double x,double y){
        exp.setX(x); 
        assertEquals(y,exp.getY(),0.001);
    }
    calculationExp(1,2.718);
    calculationExp(2,7.389);
    calculationExp(3,20.085);
    calculationExp(4,54.598);
    calculationExp(5,148.412);
    ```
9. 可目测的那一个一定要用抽出来的模板完成，因为这样相当于也在测试你的模板
	例:
    ```
    
    calculationExp(0,1);
    calculationExp(1,2.718);
    calculationExp(2,7.389);
    calculationExp(3,20.085);
    calculationExp(4,54.598);
    calculationExp(5,148.412);
    ```
	如果测试的时候发生第1条(calculationExp(0,1))报错了，我们可以很清楚的知道你的模板错了，因为我们目测就知道第1条的输入和输出没有问题，如果没有第1条，又出现了错误，看其他那些乱七八糟的数字，不知道是模板错了还是数字错了。当然，逆命题不成立。第一条不报错不代表你的模板就是对的。
10. 特殊情况一定要测试
	例：转账金额大于账户现有的金额，不能把账户转为负的
11. 边界情况一定要测试（边界情况往往就是可以目测的情况）

       例：吃包子那个，吃了2000个包子之后，饱和度不应该是无限制增长的。吃0个的时候饱和度应该是0 （或者另行规定的其他初始值）。
12. 建议不要在一个[Test]里多次Assert。 如果要用for批量测试的话，也该手动分离出来几个放在单独的[Test]里，剩下的再用for来测试
13. 测试不仅要测试对的 也要测试错的(不是让你把测试弄错)
    ```
    //如果1+1==3;那么NotEqual就报错
    //如果1+1!=3;那么NotEqual就是对的
    Assert.NotEqual(3,1+1)
    //如果()=>1/0;报错，那么Fail就是对的
    //如果()=>1/0;是对的，那么Fail就报错
    ModestTree.Assert.Throws(()=>1/0)  
    ```
14. 每个测试都是独立的 不会互相影响，除非违规使用了static变量
15. 测试总流程:
    1. 注入被你测试的东西(不要自己造)
    2. 注入需要辅助你做测试的工具(不要自己造)
    3. 如果所有的测试都要经历某些相同的初始化，写到[SETUP]环境里(以后会插入具体链接)
    4. 如果有合适的父测试，继承过来。子测试要继承父测试的SETUP,**不要覆盖**
    5. 先写一两个练手
    6. 找到共性后抽出模板
	7. 用模板进行大量的测试
    8. 别忘了一个空测试	
    9. 别忘了至少一个可以被目测正确错误的测试,如果你有多个测试模板，每个测试模板都要至少有一个可以被目测的
    10. 想想有没有被忽略的特殊情况，测试!
    11. 边界条件测试了没有？
    12. 被你测试的类上面的每一个方法都有覆盖到吗？
    13. 运行测试看看是不是你写的所有测试都通过了？(除非你天赋异禀，不然答案大概率是否定的)
    14. 如果空测试没有通过，检查配置环境(是否忘写installer,是否忘写binding)
    15. 如果可以被目测的测试没通过，再去目测一下对不对，如果正确，那么你的模板写错了
    16. 如果其他测试都通过了，但是边界条件和特殊情况没有通过，基本上可以确定你的测试是对的，并把错误告诉对应的开发人员
    17. 如果程序每次执行有时通过有时不通过，看看你是不是使用了没控制种子的随机因素
    18. 如果单独运行某个测试的时候通过，但是批量运行的时候不通过，检查你在某个地方是不是使用了全局变量(违反公司规定了)
    19. 如果你新写了一个测试,并且没有改之前的代码，导致了你之前通过的测试失败,检查你在某个地方是不是使用了全局变量(违反公司规定了)
    20. 如果出现了上述没有说到的其他情况，自己慢慢调试去吧
<center> Copyright © 2020 珠海数镜空时科技有限公司 All Rights Reserved</center>