# <center>依赖倒置原则</center>

1. 解释:高层模块不应该依赖低层模块，两者都应该依赖其抽象
2. a的代码里出现b，我们就说a依赖b
3. 现在有26个类(当成26个字母解释)
    1. 如a-->b(a依赖b)，依赖为1
    2. a-->b,b-->c, 依赖为2
    3. a<-->b,b-->c依赖为3，
    4. 可以认为一个箭头就1个依赖，要把这26个类之间的依赖降到最低，但是不允许出现连接断裂(a-->b,c-->d,a依赖b,c依赖d,四个字母之间出现了连接断裂)
    5. 例1:钢琴和音符的依赖关系(26个字母的其中一个方法)
    6. 例2:咖啡，有个智能咖啡机，有个人想喝咖啡了，他去智能咖啡机上点了一杯咖啡，咖啡机做咖啡，做好就自动送过去了
    7. 例3:咖啡，有个智能咖啡机，有个人想喝咖啡了，他去智能咖啡机上点了一杯咖啡，咖啡机做咖啡，做好了发出滴滴滴
    8. 例4:一个自动打棒球的机器，分成两个部分，打和接，一个把球打出去，一个接球
    9. 需要的类
        1. 例1的类:钢琴、音符
        2. 例2、3的类:咖啡机、人、咖啡
        3. 例4的类:打机器、球、接机器
    10. 之间的依赖关系
        1. 例1的类:钢琴依赖音符
        2. 例2、3的类:咖啡机依赖咖啡、人依赖咖啡机
            1. 事件,咖啡好了,人要处理这个事件,无论是哪个版本，咖啡都要发出这个事件,人要处理这个事件
            2. 例2,送的版本，人不需要认识咖啡机,坐在那里等就行了
            3. 例3，人需要认识咖啡机，过去取（一般情况）
        3. 例4的类:打机器瞄准接机器打出去
    11. 改善:
        1. 例1:多出来个第三方，琴键，钢琴依赖琴键来弹出音符，不同琴键发出不同的声音
        2. 例2、3:咖啡就负责发送一个事件，不管发送给谁，人就负责处理这个事件，就别管是谁发送的这个事件,唯一都需要知道的事情就是咖啡，我们可以有第三方来作为一个中转，咖啡做出来之后就扔出来，别管来取的人是谁，第三方保证会接住，第三方把咖啡扔过去给那个人,咖啡机瞎扔就行，不需要知道第三方的存在，第三方会保证把他接住，人也不需要知道第三方是谁，人只要坐在哪里等着，如果一次做多个咖啡，有精细化的要求，需要第三方判断,哪个咖啡是谁的，第三方要不停的工作
        3. 例4: 多出来个第三方自动调整打机器的角度，打机器只负责打，接机器只负责接，一次打多个球，没有精细化的要求，也可以使用丢给第三方就不管了，第三方设置好之后就不管了，一次性的初始化
    12. 改善后的依赖关系
        1. 例1的依赖关系是什么？钢琴-->琴键，音符-->琴键
        2. 例2、3的依赖关系是什么？第三方-->咖啡机,第三方-->人
        3. 例4的依赖关系是什么？第三方-->打机器,第三方-->接机器
        4. 在例1里,琴键相当于多出来的第三方，它是被所有箭头指向的，而例2、3、4里面是反过来指向其他类的，所以在例2、3、3里面第三方可以随时被删掉，之后整个系统的依赖为零，但是例1里的第三方如果删掉会导致代码根本无法编译，所以灵活辨别什么情况该用什么样的第三方(两种都是必要的)
4. 图解:
![img](../img/d.jpg )

<center> Copyright © 2021 天下数学引擎科技（深圳）有限公司 All Rights Reserved</center>