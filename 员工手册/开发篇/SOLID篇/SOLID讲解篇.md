# <center>SOLID讲解篇</center>

1. 第4条，S原则，这个东西只能干一件事情，所以为什么要用不同的方法去初始化
	1. 如果构造函数B比构造函数A更详细，因为S要求，实现的功能是一模一样的，使用构造函数A仍然能够完整的完成这个问题，请问更详细的意义在哪里？
	2. 如果A、B完成的功能稍微不一样，A的质量比B的质量稍微欠缺一点，B应该是A的一个升级，那么明显把B作为A的子类是更好的，因为它明显符合L
	3. 如果A、B截然不同，两个截然不同的实现方法去达到同一个功能去满足同一个接口，这叫多态，所以AB应该是两种平级的多态
	4. 一个类只有一个构造函数，使得依赖注入框架可以知道如何自动去构造，因为只有一个
2. 第6条
    1. 使你的测试变得非常困难
	例：测试的时候有时候全局变量状态好就通过了，有时候全局变量状态不好就测试就没通过，而且完全没有任何征兆，因为它是隐藏在某个地方的全局变量，不知道是因为什么因素，触发了全局变量把全局变量改了，上一秒测试还通过，下一秒测试就不通过了
	2. 使你的代码无法扩展
    例1:拿破仑征服其他国家，一开始征服法国，把法国的范围设定为全局，征服了法国之后要怎么去征服欧洲？怎么去征服地球？怎么去征服宇宙？一开始就把全局变量的范围划好了，要征服法国，如果要征服欧洲要怎么办？被一开始划定好的范围固定住了
	例2：超级玛丽的游戏，一个玩家的变量（全局变量），听起来好像挺有道理的，因为这个玩家变量要跟所有功能发生关系，放到全局挺方便的，那后续要开发双人模式了怎么办？你一开始就把这个变量设定好了只有一个玩家，后面要扩展的时候要怎么扩展？
    例3:一个word文档，有一个全局变量来计算文档的字数，后面升级了，有多开文档了，这个全局变量要怎么办？
3. 第7条，因为静态是全局··跟上一条一样
4. 第8条，因为单例是全局··跟上一条一样
5. 第9条
    1. 如果用两个随机数生成器，很可能在很短的时间内用到了同一个时间种子，导致这两个随机数生成器生成的随机数是一样的
	2. 不被控制的随机数生成器，其实在暗中用一个时间的全局变量，把时间作为种子，涉及到全局变量的问题
	3. 如果说想要重复之前的某个种子，而时间已经过去了，没有控制好种子，再也看不到想要重复的情况
6. 第13条，因为有些东西本来就不应该让你改，比如说银行账户里面的钱，能把set()开放出去吗？只能用转账这个功能去间接的改变他，是权限的一个管理，同时它也是保护内部的逻辑不出错，比如说有一个游乐园，要统计里面有多少个人，最笨的方法把园里面的所有人都数一边，最好的方法是进来一个人+1，出去一个人-1，只有通过这个门才能进出，现在忽然在墙上打了个洞，不经过门，从洞里面进出的人你没统计到，本来设计得好好的一个，因为你把get()、set()开放出去了你不知道谁进去谁出去了，统计的时候又要把所有人数一遍，更具体的原因:查阅封装性，违反了O原则的闭
7. 第14条，原因跟get()，set()一样，把get(),set()开放出去就相当于把它public了，为什么如果服从接口隔离的时候就不重要，因为你无法通过接口直接访问到变量，接口会自动把变量隔离出去,即使是public变量，所以变量是不是public已经不重要了，前提是你做到了全局都只暴露接口，不暴露class，才可以有这么大的信心，如果暴露了部分class，那么最薄弱的一环仍然是暴露出去了，例：现在的疫情，要做到全市一个病人都没有，才可以放心的扔掉口罩出去玩，只要有一个暴露出去了，都得戴着口罩，测体温
8. 第15条，O原则，要保证继承你的东西可以修改，要给它最大的权限，我已经不允许你修改这个类本身了，本身无法被修改了，你现在唯一的希望就是修改继承出去的东西，所以要给继承出去的东西最大的权限，让它彷佛能直接修改这个类一样，让它能够直接修改继承出来的代码，除非有非常特殊的权限安全考虑。对继承开放，对修改封闭，protected对继承开放，private对继承封闭
9. 第18条
	例：

    ```
    void Eat(Apple apple);
    void Eat(Banana banana);
    ⇒
    void Eat(Food food);
    ```
    为什么不要重载？因为重载的要求极其严格不是普通码农能轻易掌握的。
    看如下例子：
    ```
    实数 Add(实数 a, 实数 b);//实数加法
    复数 Add(复数 a, 复数 b);//复数加法
    ```
    问:
    现在有个圆周率的类 同时继承实数接口和复数接口。
    因为 3.14既可以多态成实数，也可以多态成复数(3.14+0i)
    那么Add(圆周率,圆周率)应该被解释为实数版的Add还是复数版的Add？
    通过基本数学常识我们知道：这不重要，因为结果都一样。一致性。
    不提编译器本身语言的局限性，光是这种一致性就不是一般码农可以精确达到的。
10. 第19条，L，只有符合L的情况下才能继承
11. 第22条，编译器看不懂你的注释，其他人懒得去看你的注释，注释也是一种重复，用代码实现了一遍这种功能，又用注释解释了一遍这种功能，实际上也是一种重复，你应该命名清楚他是做什么的，而不是注释清楚他是做什么的，如果命名出现了困难，见S原则
12. 第24条，在代码里面出现的数字是一种常数，常数是以一种特殊的静态，静态是一种全局，而且还是一种无法被重复利用的全局，集各种毛病于一身
13. 第25条，I、D：强制要求把接口抽象出来、L: 改容器，例：有一个宠物，不把接口抽象出来，写成一个猫，后来猫玩够了，想要换成老虎，要把老虎当宠物，要改动就很麻烦，如果一开始抽离一个宠物出来，现在是猫，用L原则，用老虎替换下来，只要通过改容器，用老虎替换之前的猫就可以了.可参考[TDD](../../测试篇/测试篇.md)
14. 第26条，D，只能够依赖接口，不能够依赖类
15. 第28条，违反了L，子类必须可以替换父类还不产生错误，而null什么都可以替换，替换什么都会导致错误，会导致莫名其妙很难debug的空指针异常,会迫使你在所有地方检查空指针异常，因为你的代码逻辑允许了空指针。应该从根本上就不允许空指针的存在，比如疫情，只要有一个病人，就得戴口罩测体温，如果从根本上就没有病人，那么不用到处测体温戴口罩
16. 第29条，无法多态，也无法扩展，违反了1。另原因见2。
17. 第30条，String相当于是一种人类可读的二进制序列，String的每一个字符都是二进制序列(0101011010...),但是我们有其他更好的人类可读的，比如类名，一个好好命名class同样也可以做到人类可读，二进制序列有一个问题，机器无法解读，比如010010，int类型机器可能把它解读成9，转成String可能是a,....机器怎么解读它？必须配合告诉它是什么类型。机器无法解读String，同样也无法解读二进制序列，我们有更好的选择，class人可以读懂，机器也可以读懂。
18. 第31条，不要直接去依赖第三方，要去依赖第三方的接口，如果第三方有接口了就去用，如果没有，就造接口
19. 第32条，用断点debug会更好，使用大量的print会导致代码看起来很糟糕
20. 第33条，S原则，如果你是负责测试它的就不要去创造它，如果你去创造它的话，你是不是调用了它的构造函数（违反了构造函数不可以重复使用的规则），调用了构造函数是不是绕过了接口直接发生了依赖，违反了D，**应该直接注入它的接口。** 因为你没办法构造它的接口，所以不跟它的实体类产生依赖。

<center> Copyright © 2021 天下数学引擎科技（深圳）有限公司 All Rights Reserved</center>
